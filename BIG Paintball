--[[

-- DUMP THE GOOD SHIT

local string = '---------------------------------------------'

for i, v in next, getgc(true) do
	if type(v) == 'table' and rawget(v, 'damage') then
		for i2, v2 in pairs(v) do
			string = string .. '\n'
			string = string .. tostring(i2) .. ' ' .. tostring(v2) .. '\n'
		end
		string = string .. '\n-------------------------------------\n'
	end
end
writefile('PAINTBALL DUMP.txt', string)
]]--

repeat task.wait() until game:IsLoaded()
if not hookmetamethod then game.Players.LocalPlayer:Kick('You need a lv7 Executor like krnl or Synapse') end

-- [Gun Mods] --

getgenv().GunMods = true

if getgenv().GunMods then
	for i, v in next, getgc(true) do
		if type(v) == 'table' and rawget(v, 'damage') then
			v.shotrate = 0.00000001
			v.automatic = true
			v.damage = math.huge
			v.velocity = 1000
		end
	end
else
	for i, v in next, getgc(true) do
		if type(v) == 'table' and rawget(v, 'damage') then
			v.shotrate = v.shotrate
			v.automatic = v.automatic
			v.damage = v.damage
			v.velocity = v.velocity
		end
	end
end

-- [Find Character] --

local UIS = game.UserInputService
local Character = game.Players.LocalPlayer.Character

if not Character then
	game.Players.LocalPlayer.CharacterAdded:Connect(function(char)
		getgenv().Teleport = true
		getgenv().Aimbot = true
		Character = char
		Character:WaitForChild('Humanoid').Died:Connect(function()
			getgenv().Teleport = false
			getgenv().Aimbot = false
			Character = nil
    	end)
	end)
end

-- Define a coroutine that waits for Character and its HumanoidRootPart
function WaitForCharacter()
    while not Character or not Character:FindFirstChild('HumanoidRootPart') do
        wait()
    end
    return Character
end

-- Wrap the coroutine in a function that can be called later
function GetCharacter()
    return WaitForCharacter()
end

-- [Get Closest Player] --

local closest;

function GetClosest()
	local ClosestPlayer = 100
	local Character = GetCharacter()
	for i, v in pairs(game.Players:GetPlayers()) do
		if Character and Character:FindFirstChild('HumanoidRootPart') and v.Character and v.Character:FindFirstChildOfClass('Humanoid') and v.Character.Humanoid.Health ~= 0 and v.Team ~= game.Players.LocalPlayer.Team then
			local Distance = math.min(50, (Character.HumanoidRootPart.Position - v.Character.HumanoidRootPart.Position).magnitude)
			if Distance ~= 0 and Distance < ClosestPlayer then
				ClosestPlayer = Distance
				closest = v.Character
			end
		end
	end
	return closest
end

--[[
-- [Teleport] --

getgenv().Teleport = true

spawn(function()
	while getgenv().Teleport do
		local Character = GetCharacter()
		if Character and Character:FindFirstChild('HumanoidRootPart') and Character:FindFirstChild('Humanoid').Health ~= 0 then
			if GetClosest() then
				local targetPos = GetClosest().HumanoidRootPart.Position + Vector3.new(0, 6, -3)
				local tweenInfo = TweenInfo.new((targetPos - Character.HumanoidRootPart.Position).Magnitude / 100, Enum.EasingStyle.Linear, Enum.EasingDirection.In)
				local tween = game:GetService('TweenService'):Create(Character.HumanoidRootPart, tweenInfo, {CFrame = CFrame.new(targetPos)})
				tween:Play()
			end
		end
	end
	wait(0.2)
end)
]]--

-- [Aimbot] --

getgenv().Aimbot = true

if getgenv().Aimbot then

	local players = game:GetService('Players')
	local RunService = game:GetService('RunService')
	local Teams = game:GetService('Teams')
	local user_input_service = game:GetService('UserInputService')
	local workspace = game:GetService('Workspace')

	local camera = workspace.CurrentCamera
	local wtvp = camera.WorldToViewportPoint
	local localplayer = players.LocalPlayer

	local function indexExists(object, index)
	    local _, value = pcall(function() return object[index] end)
	    return value
	end

	local function get_character(player) return indexExists(player, 'Character') end

	local function get_mouse_location() return user_input_service:GetMouseLocation() end

	local function is_alive(player) return player.Character and player.Character:FindFirstChild('Humanoid') and player.Character:FindFirstChild('Humanoid').Health > 0 end
	local function is_team(player) return #Teams:GetChildren() > 0 and player.Team == localplayer.Team end

	local function getClosestPlayerToCursor(fov)

	    local maxDistance = fov or math.huge

	    local closestPlayer = nil
	    local closestPlayerDistance = math.huge

	    for _, player in pairs(players:GetPlayers()) do

		if player ~= localplayer and not is_team(player) and get_character(player) and is_alive(player) then
		    local pos, on_screen = wtvp(camera, get_character(player).Head.Position)

		    if not on_screen then continue end

		    local distance = (get_mouse_location() - Vector2.new(pos.X, pos.Y)).magnitude

		    if distance <= maxDistance and distance < closestPlayerDistance then
			closestPlayer = player
			closestPlayerDistance = distance
		    end
		end
	    end

	    return closestPlayer
	end

	shared.fov = 400
	local circle = Drawing.new('Circle')
	circle.Thickness = 2
	circle.NumSides = 64
	circle.Radius = shared.fov or 400
	circle.Filled = false
	circle.Transparency = 1
	circle.Color = Color3.new(1, 0, 0.384313)
	circle.Visible = true
	local target = nil
	RunService.Heartbeat:Connect(function(deltaTime)
	    task.wait(deltaTime ^ 2)
	    target = getClosestPlayerToCursor(shared.fov)
	    circle.Position = get_mouse_location()
	end)

	local OldNamecall
	OldNamecall = hookmetamethod(workspace, '__namecall', newcclosure(function(...)
	    local args = { ... }
	    local method = string.lower(getnamecallmethod())
	    local caller = getcallingscript()
	    if method == 'findpartonraywithwhitelist' and tostring(caller) == 'First Person Controller' then

		local HitPart = target and target.Character and target.Character.Head or nil
		if HitPart then
		    local Origin = HitPart.Position + Vector3.new(0, 5, 0)
		    local Direction = (HitPart.Position - Origin)
		    args[2] = Ray.new(Origin, Direction)

		    return OldNamecall(unpack(args))
		else
		    return OldNamecall(...)
		end
	    end
	    return OldNamecall(...)
	end))
end
