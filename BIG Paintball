--[[

--> Dumps the tables with a damage constant <--

local string = '---------------------------------------------'

for i, v in next, getgc(true) do
	if type(v) == 'table' and rawget(v, 'damage') then
		for i2, v2 in pairs(v) do
			string = string .. '\n'
			string = string .. tostring(i2) .. ' ' .. tostring(v2) .. '\n'
		end
		string = string .. '\n-------------------------------------\n'
	end
end
writefile('PAINTBALL DUMP.txt', string)
]]--

-- [Gun Mods] --

for i, v in next, getgc(true) do
	if type(v) == 'table' and rawget(v, 'damage') then
		v.shotrate = 0.0001
		v.automatic = true
		v.damage = math.huge
		v.velocity = 500
	end
end

-- [Find Character] --

local Character = game.Players.LocalPlayer.Character

if not Character then
	game.Players.LocalPlayer.CharacterAdded:Connect(function(char)
		getgenv().Teleport = true
		getgenv().Aimbot = true
		Character = char
		Character:WaitForChild('Humanoid').Died:Connect(function()
			getgenv().Teleport = false
			getgenv().Aimbot = false
			Character = nil
    	end)
	end)
end

-- Define a coroutine that waits for Character and its HumanoidRootPart
function WaitForCharacter()
    while not Character or not Character:FindFirstChild('HumanoidRootPart') do
        wait()
    end
    return Character
end

-- Wrap the coroutine in a function that can be called later
function GetCharacter()
    return WaitForCharacter()
end

-- [Locals] --

local players = game:GetService('Players')
local RunService = game:GetService('RunService')
local Teams = game:GetService('Teams')
local user_input_service = game:GetService('UserInputService')
local workspace = game:GetService('Workspace')

local camera = workspace.CurrentCamera
local wtvp = camera.WorldToViewportPoint
local localplayer = players.LocalPlayer

--> ESP <--

--> Tracers <--
		
getgenv().Tracers = true
		
while getgenv.Tracers do
	for i, v in next, players:GetChildren() do
		local Line = Drawing.new('Line')
		Line.Thickness = 5
		Line.Color = Color3.new(217, 38, 38)
		Line.From;
		Line.To;

		RunService.Heartbeat:Connect(function()
			if v.Character and v.Character:FindFirstChild('Humanoid') and v.Character:FindFirstChild('Humanoid').Health ~= 0 and and v ~= localplayer and v.Team ~= localplayer.Team then
				local Vector, OnScreen = camera:worldToViewPortPoint(v.Character.HumanoidRootPart.Position)
				
				if OnScreen then
					Tracer.From = Vector.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y * 2)
					Tracer.To = Vector2.new(Vector.X, Vector.Y)
					Tracer.Visible = getgenv().Tracers
				else
					Tracer.Visible = false
				end
			end
		end)
	else
		Tracer.Visible = getgenv().Tracers
	end
end

-- [Aimbot] --

getgenv().Aimbot = true

task.spawn(function()
	if getgenv().Aimbot then

		local function indexExists(object, index)
		    local _, value = pcall(function() return object[index] end)
		    return value
		end

		local function get_character(player) return indexExists(player, 'Character') end

		local function get_mouse_location() return user_input_service:GetMouseLocation() end

		local function is_alive(player) return player.Character and player.Character:FindFirstChild('Humanoid') and player.Character:FindFirstChild('Humanoid').Health > 0 end
		local function is_team(player) return #Teams:GetChildren() > 0 and player.Team == localplayer.Team end
		
		--> FOV <--
		
		shared.fov = 800
		local circle = Drawing.new('Circle')
		circle.Thickness = 2
		circle.NumSides = 64
		circle.Radius = shared.fov or 800
		circle.Filled = false
		circle.Transparency = 1
		circle.Color = Color3.new(1, 0, 0.384313)
		circle.Visible = false -- Make it changable
		local target = nil

	--> [Get Closest Player] <--

	local function getClosestPlayerToCursor(fov)

		    local maxDistance = fov or math.huge

		    local closestPlayer = nil
		    local closestPlayerDistance = math.huge

		    for _, player in pairs(players:GetPlayers()) do

			if player ~= localplayer and not is_team(player) and get_character(player) and is_alive(player) then
			    local pos, on_screen = wtvp(camera, get_character(player).Head.Position)

			    if not on_screen then continue end

			    local distance = (get_mouse_location() - Vector2.new(pos.X, pos.Y)).magnitude

			    if distance <= maxDistance and distance < closestPlayerDistance then
				closestPlayer = player
				closestPlayerDistance = distance
			    end
			end
		    end

		return closestPlayer
	end

		RunService.Heartbeat:Connect(function(deltaTime)
		    task.wait(deltaTime ^ 2)
		    target = getClosestPlayerToCursor(shared.fov)
		    circle.Position = get_mouse_location()
		end)

		local OldNamecall
		OldNamecall = hookmetamethod(workspace, '__namecall', newcclosure(function(...)
		    local args = { ... }
		    local method = string.lower(getnamecallmethod())
		    local caller = getcallingscript()
		    if method == 'findpartonraywithwhitelist' and tostring(caller) == 'First Person Controller' then

			local HitPart = target and target.Character and target.Character.Head or nil
			if HitPart then
			    local Origin = HitPart.Position + Vector3.new(0, 5, 0)
			    local Direction = (HitPart.Position - Origin)
			    args[2] = Ray.new(Origin, Direction)

			    return OldNamecall(unpack(args))
			else
			    return OldNamecall(...)
			end
		    end
		    return OldNamecall(...)
		end))
	end
end)

-- [Fly] --
function Fly()
	local bg = Instance.new("BodyGyro", torso)
	bg.P = 9e4
	bg.maxTorque = Vector3.new(9e9, 9e9, 9e9)
	bg.cframe = torso.CFrame
	local bv = Instance.new("BodyVelocity", torso)
	bv.velocity = Vector3.new(0,0.1,0)
	bv.maxForce = Vector3.new(9e9, 9e9, 9e9)
	repeat wait()
		plr.Character.Humanoid.PlatformStand = true
		if ctrl.l + ctrl.r ~= 0 or ctrl.f + ctrl.b ~= 0 then
			speed = speed+.5+(speed/maxspeed)
			if speed > maxspeed then
				speed = maxspeed
			end
		elseif not (ctrl.l + ctrl.r ~= 0 or ctrl.f + ctrl.b ~= 0) and speed ~= 0 then
			speed = speed-1
			if speed < 0 then
				speed = 0
			end
		end
		if (ctrl.l + ctrl.r) ~= 0 or (ctrl.f + ctrl.b) ~= 0 then
			bv.velocity = ((game.Workspace.CurrentCamera.CoordinateFrame.lookVector * (ctrl.f+ctrl.b)) + ((game.Workspace.CurrentCamera.CoordinateFrame * CFrame.new(ctrl.l+ctrl.r,(ctrl.f+ctrl.b)*.2,0).p) - game.Workspace.CurrentCamera.CoordinateFrame.p))*speed
			lastctrl = {f = ctrl.f, b = ctrl.b, l = ctrl.l, r = ctrl.r}
		elseif (ctrl.l + ctrl.r) == 0 and (ctrl.f + ctrl.b) == 0 and speed ~= 0 then
			bv.velocity = ((game.Workspace.CurrentCamera.CoordinateFrame.lookVector * (lastctrl.f+lastctrl.b)) + ((game.Workspace.CurrentCamera.CoordinateFrame * CFrame.new(lastctrl.l+lastctrl.r,(lastctrl.f+lastctrl.b)*.2,0).p) - game.Workspace.CurrentCamera.CoordinateFrame.p))*speed
		else
			bv.velocity = Vector3.new(0,0.1,0)
		end
		bg.cframe = game.Workspace.CurrentCamera.CoordinateFrame * CFrame.Angles(-math.rad((ctrl.f+ctrl.b)*50*speed/maxspeed),0,0)
	until not flying
		ctrl = {f = 0, b = 0, l = 0, r = 0}
		lastctrl = {f = 0, b = 0, l = 0, r = 0}
		speed = 0
		bg:Destroy()
		bv:Destroy()
		plr.Character.Humanoid.PlatformStand = false
	mouse.KeyDown:connect(function(key)
		if key:lower() == "e" then
			if flying then flying = false
			else
				flying = true
				Fly()
			end
		elseif key:lower() == "w" then
			ctrl.f = 1
		elseif key:lower() == "s" then
			ctrl.b = -1
		elseif key:lower() == "a" then
			ctrl.l = -1
		elseif key:lower() == "d" then
			ctrl.r = 1
		end
	end)
	mouse.KeyUp:connect(function(key)
		if key:lower() == "w" then
			ctrl.f = 0
		elseif key:lower() == "s" then
			ctrl.b = 0
		elseif key:lower() == "a" then
			ctrl.l = 0
		elseif key:lower() == "d" then
			ctrl.r = 0
		end
	end)
	
	Fly()
end
